/*--------------------------------------------------------------------------------
    ooo      L   attice-based  |
  o\.|./o    e   xtensible     | LeMonADE: An Open Source Implementation of the
 o\.\|/./o   Mon te-Carlo      |           Bond-Fluctuation-Model for Polymers
oo---0---oo  A   lgorithm and  |
 o/./|\.\o   D   evelopment    | Copyright (C) 2013-2015 by
  o/.|.\o    E   nvironment    | LeMonADE Principal Developers (see AUTHORS)
    ooo                        |
----------------------------------------------------------------------------------

This file is part of LeMonADE.

LeMonADE is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

LeMonADE is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with LeMonADE.  If not, see <http://www.gnu.org/licenses/>.

--------------------------------------------------------------------------------*/

#ifndef LEMONADE_CORE_INGREDIENTS_H
#define LEMONADE_CORE_INGREDIENTS_H

#include <vector>
#include <string>

#include <LeMonADE/core/ConfigureSystem.h>

/***************************************************************************************/
/**
* @file
*
* @class Ingredients
* @brief Definition of class Ingredients holding all physical information of a simulated or analyzed system.
*
* @details This class holds all the information of the simulated or analyzed system, in
* other words, the Ingredients of the system. The template argument MoleculesType
* specifies the structure holding the information about the contained particles.
* This could for example be a graph structure (monomers + conectivity), or
* something simple containing essentially only a vector of monomers. The only
* prerequisites are a typedef MoleculesType::vertex_type, defining the data type
* of the monomers, and functions MoleculesType::getMonomer(int) and
* MoleculesType::modifyMonomer(int).
* Any other system information, e.g. simulation box, set of bondvectors, interaction
* parameters, or others, are specified through the template argument FeatureList.
* By deriving from the class GenerateContextType<FeatureList>, the class Ingredients
* automatically inherits all Features given in FeatureList. For example:
* \code
* typedef LOKI_TYPELIST_2<FeatureBox,FeatureBondset> features;
* Ingredients<MoleculeContainer, features> bfmSystem;
* \endcode
*
* defines a system that contains an instance of a hypothetical class MoleculeContainer,
* which can hold all the particles, and that additionally has all functions
* defined by the features FeatureBox and FeatureBondset, i.e. one could call
* the function bfmSystem.modifyBondset(), which is defined in FeatureBondset.
*
* @tparam Config Configuration holding the typedefs that define the type of system (features, monomers...).
* The typedefs defining the base type for Ingredients ( context_type ), type of monomers used (monomer_type), type of the graph used to organize the monomers (molecules_type)
* and the list of features used. Additionally holds a number MY_ERRORSTATE indicating possible
* problems with the features in use.
**/
/***************************************************************************************/

template <class Config> class Ingredients: public Config::context_type
{
public:

	//! Definition of the the molecules_type esp. graph properties
	typedef  typename Config::molecules_type  molecules_type;

	//! Definition of the the feature list of the system
	typedef  typename Config::feature_list feature_list;

	//! Definition of the the vertex type esp. monomer properties (Vector3D, AttributeTag..)
	typedef typename Config::molecules_type::vertex_type monomer_type;

	//! Base class of Ingredients. Contains information generated by the features used.
	typedef typename Config::context_type context_type;

private:

	//! Molecules graph holding references to all monomers, connectivity etc.
	molecules_type molecules;

	//! Vector of metadata comments of the system describing the system properties
	std::vector <std::string> comments;

	//! Variable to name this specialized Ingredients. FileImport is using \var name for filename.
	std::string name;

public:


	/**
	 * @brief Ingredients Constructor
	 *
	 * @details The constructor configures/initializes the system by resolving all feature dependencies
	 * and system related properties.
	 *
	 * @throw <std::runtime_error> if the configuration of system fails.
	 *
	 * @param name Initialize the Ingredients with name.
	 */
	Ingredients(std::string name = "new_lemonade")
	:name(name)
	{
	  if (Config::MY_ERRORSTATE >0){
		  std::stringstream errormessage;
	    errormessage<<"The software could not resolve all feature dependencies\n"
		<<"Please check the forward- and backwards-requirements of the features in use.\n"
		<<"In some cases you may be able to solve the issue by changing the order of the features in your list"
		<<std::endl;
	    throw std::runtime_error(errormessage.str());
	  }
	}

	/**
	 * @todo testing!!!
	 *
	 * @param copyIng
	 */
	Ingredients(const Ingredients& copyIng) // Kopierkonstruktor
	    {
#ifdef DEBUG
		//putting this output here, because it is not used often normally,
		//and can potentially cause trouble if copy constructors of
		//features are not implemented correctly
	        std::cout << "Ingredients copy constructor" << std::endl;
#endif /*DEBUG*/
	        // copy external data
	        molecules = copyIng.molecules;
	        comments = copyIng.comments;
	        //copy other data
	        name = copyIng.name;

	        *reinterpret_cast < typename Config::context_type* > (this) = copyIng;

	        this->synchronize(*this);
	    }

	/**
	 * @todo testing!!!
	 *
	 * @param IngredientsSource
	 * @return
	 */
	Ingredients& operator= (const Ingredients &IngredientsSource)
	{
#ifdef DEBUG
		//putting this output here, because it is not used often normally,
		//and can potentially cause trouble if copy constructors of
		//features are not implemented correctly
		std::cout << "assignement" << std::endl;
#endif /*DEBUG*/
		// check for self-assignment by comparing the address of the
		// implicit object and the parameter
		if (this == &IngredientsSource)
			return *this;

		// do the copy
		molecules = IngredientsSource.molecules;
		comments = IngredientsSource.comments;
		name = IngredientsSource.name;

		*reinterpret_cast < typename Config::context_type* > (this) = IngredientsSource;

		this->synchronize(*this);
		// return the existing object
		return *this;
	}

	/**
	 * @brief Get a constant reference to the complete graph of Molecules.
	 *
	 * @details This function should be called to get a read-only reference to all Molecules to prevent
	 * unauthorized access of member functions.
	 *
	 * @return constant reference to Molecules esp. graph.
	 */
	const molecules_type& getMolecules() const
	{
		return molecules;
	}

	/**
	 * @brief Get a a non-const reference to the complete graph of Molecules.
	 *
	 * @details This function should be called to get a read-write reference to all Molecules esp. graph.
	 * This framework should be used if the member functions need read/write access to the system.
	 *
	 * @return non-constant reference to Molecules esp. graph for read/write.
	 */
	molecules_type& modifyMolecules()
	{
		return molecules;
	}

	/**
	 * @brief Synchronizes the Features and establishing consistency in the system.
	 *
	 * @details This function only calls the function
	 * context_type::synchronize(Ingredients&) with itsself as argument. Thus
	 * it causes all features to subsequently call their synchonize routines.
	 * Calling this function on an instance ( "ingredients.synchronize();" )
	 * is equivalent to calling  "ingredients.synchonize(ingredients));"
	 */
	void synchronize()
	{
		context_type::synchronize(*this);
	}

	/**
	 * @brief Synchronizes the Features and establishing consistency in the system.
	 *
	 * @details This function only calls the function
	 * context_type::synchronize(Ingredients& ing). Thus it causes all features
	 * to subsequently call their synchonize routines with the same argument.
	 * This function allows to synchronize one instance of Ingredients with
	 * another instance.
	 *
	 * @param ingredients A reference to the Ingredients instance to synchronize with
	 */
	template<class IngredientsType>
	void synchronize(IngredientsType& ing)
	{
		context_type::synchronize(ing);
	}

	/**
	 * @brief Export the relevant functionality of all meta-information and molecules
	 * for reading bfm-files.
	 *
	 * @details This function delegates all read-in functionality to the Molecules graph
	 * and export every read-in to context_type.
	 *
	 * @param file The responsible reader object.
	 */
	template<class FileRead>
	void exportRead(FileRead& file)
	{
		context_type::exportRead(file);
	}

	/**
	 * @brief Export the relevant functionality of all meta-information and molecules
	 * for writing bfm-files.
	 *
	 * @details This function delegates all write-out functionality to the Molecules graph
	 * and export every write-out to context_type.
	 *
	 * @param file The responsible writer object.
	 */
	template<class FileWriter>
	void exportWrite(FileWriter& file) const
	{
		context_type::exportWrite(file);
	}

	/**
	 * @brief Overloaded function to stream all metadata to an output stream
	 *
	 * @details Gives all unregistered features and additional metadata comments.
	 *
	 * @param stream output stream
	 */
	void printMetaData(std::ostream& stream) const {

		stream << std::endl << "registered features: " << std::endl << std::endl;
		context_type::printMetaData(stream);
		stream << std::endl << "not registered features: " << std::endl << std::endl << getSumOfComments() << std::endl;
	}

	/**
	 * @brief Adding metadata information the the system.
	 *
	 * @param comment Metadata information
	 */
	void addComment(std::string comment){comments.push_back(comment);}

	/**
	 * @brief Gathering of all metadata of the system into a list.
	 *
	 * @return All metadata information in Ingredients.
	 */
	std::string getSumOfComments() const
	{
		std::string SumOfComments;
		for (size_t i=0; i<comments.size(); ++i){
			SumOfComments += comments[i];
		}
		return SumOfComments;
	}

	/**
	 * @brief Getting the specified name of this Ingredients.
	 *
	 * @return The name of this Ingredients.
	 */
	const std::string& getName() const { return name; }

	/**
	 * @brief Setting the specified name of this Ingredients.
	 *
	 * @param _name The name to set of this Ingredients.
	 */
	void setName( const std::string& _name ) { name = _name ;}

};

#endif

